// Generated by CoffeeScript 1.8.0

/*
 * ObjectoPatronum helps in [g|s]etting values [from|to] the deep
 */
var a, objectoPatronum;

objectoPatronum = (function() {
  return {
    isArray: function(val) {
      return Object.prototype.toString.call(val) === "[object Array]";
    },
    isObject: function(val) {
      return Object.prototype.toString.call(val) === "[object Object]";
    },
    isNumeric: function(val) {
      return isFinite(val) && Object.prototype.toString.call(+val) === "[object Number]";
    },
    fixKey: function(val) {
      if (objectoPatronum.isNumeric(val)) {
        val = +val;
      }
      return val;
    },

    /*
    	 * Reads value from object through path
    	 * @param obj {Object}
    	 * @param path {String} - e.g. 'a.foo.1.bar'
     */
    invito: function(obj, path) {
      var key;
      if (!this.isArray(path)) {
        path = (path.split(".")).reverse().map(this.fixKey);
      }
      key = path.pop();
      if (path.length === 0 || !Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
      }
      return this.invito(obj[key], path);
    },

    /*
    	 * Writes value to object through path
    	 * @param obj {Object}
    	 * @param path {String} - e.g. 'a.foo.bar'
    	 * @param value {Mixed}
    	 * @param create {Boolean} - whether it should build non-existent tree or not
     */
    missito: function(obj, path, value, create) {
      var key;
      if ((create == null) || create === void 0) {
        create = true;
      }
      if (!this.isArray(path)) {
        path = (path.split(".")).reverse().map(this.fixKey);
      }
      key = path.pop();
      if (path.length === 0) {
        return obj[key] = value;
      }
      if (!Object.prototype.hasOwnProperty.call(obj, key) || obj[key] === void 0) {
        if (create === true) {
          if (this.isNumeric(path[path.length - 1])) {
            obj[key] = [];
          } else {
            obj[key] = {};
          }
        } else {
          throw new Error("Value not set, because creation is set to false!");
        }
      }
      this.missito(obj[key], path, value, create);
    },

    /*
    	 * Delete property from object
    	 * @param obj {Object}
    	 * @param path {String|Reversed array}
     */
    evapores: function(obj, path) {
      var key, parent;
      console.log(path);
      if (!this.isArray(path)) {
        path = (path.split(".")).map(this.fixKey);
      }
      key = path.pop();
      path.reverse();
      parent = this.invito(obj, path);
      if (this.isObject(parent)) {
        delete parent[key];
      }
      if (this.isArray(parent) && this.isNumeric(key)) {
        parent.splice(key, 1);
      }
    },

    /*
    	 * Delete backwards until sibling is found
    	 * @param obj
    	 * @param path
     */
    evaporesMaxima: function(obj, path) {
      if (!this.isArray(path)) {
        path = (path.split(".")).map(this.fixKey);
      }
      while (this.siblingumRevelio(obj, path.join(".")).length === 0) {
        path.pop();
      }
      this.evapores(obj, path);
    },

    /*
    	 * Reduce objects not used trees
    	 * First
    	 * @param obj {Object}
     */
    reductoValues: [void 0, null, "", [], {}],
    reductoKeys: ["i"],
    reducto: function(obj, path, origin) {
      var evaporesPath, key, keys, _i, _len;
      if ((origin == null) || origin === void 0) {
        origin = obj;
      }
      if ((path == null) || path === void 0) {
        path = [];
      }
      if (!this.isArray(path)) {
        path = path.split(".");
      }
      if (this.isObject(obj) || this.isArray(obj)) {
        keys = Object.keys(obj);
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          path.push(key);
          this.reducto(obj[key], path.join("."), origin);
          path.pop();
        }
      } else {
        evaporesPath = path.join(".");
        console.log(evaporesPath);
        if (this.reductoValues.indexOf(obj) !== -1 || this.reductoKeys.indexOf(path.pop()) !== -1) {
          this.evaporesMaxima(origin, evaporesPath);
        }
      }
    },

    /*
    	 * Reveals current paths sibling properties
    	 * @param obj {Object}
    	 * @param path {String}
     */
    siblingumRevelio: function(obj, path) {
      var key, parent, siblings;
      if (!this.isArray(path)) {
        path = (path.split(".")).map(this.fixKey);
      }
      key = path.pop();
      parent = this.invito(obj, path.join("."));
      siblings = Object.keys(parent);
      siblings.splice(siblings.indexOf(key), 1);
      return siblings;
    }
  };
})();

a = {
  b: 1,
  c: {
    e: void 0,
    d: [
      null, void 0, "", [
        1, 2, 3, {
          a: 1,
          b: 2
        }
      ]
    ],
    f: {
      g: "asdf",
      h: {
        i: 1,
        j: void 0,
        k: void 0,
        l: {
          m: {
            n: {
              o: void 0
            }
          }
        }
      }
    }
  }
};
